<?xml version="1.0" encoding="UTF-8"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" elementFormDefault="qualified" attributeFormDefault="unqualified"
	xmlns:GEN="urn:test:XML_TradingGeneric:1_0_0" xmlns:PHD="urn:test:XML_ProductHeader:1_0_0" xmlns:REF="urn:test:XML_ReferentialGeneric:1_0_0"
	xmlns:TRD="urn:test:XML_Trade:1_0_0" xmlns:TCD="urn:test:XML_TradeConditions:1_0_0" xmlns:PTY="urn:test:XML_TradingParty:1_0_0"
	xmlns:THD="urn:test:XML_TradeHeader:1_0_0" xmlns:INS="urn:test:XML_InstrumentService:1_0_0" targetNamespace="urn:test:XML_ProductHeader:1_0_0">
	<!-- *********************************************** -->
	<!--Version Of The Package -->
	<xs:annotation>
		<xs:documentation>
			<package name="XML_ProductHeader" mnemonic="PHD" version="1.0.0" />
		</xs:documentation>
	</xs:annotation>
	<!-- *********************************************** -->
	<!--Include DEFIML shared elements -->
	<xs:import namespace="urn:test:XML_ReferentialGeneric:1_0_0" schemaLocation="../XML_Generic/XML_referential_generic.xsd" />
	<xs:import namespace="urn:test:XML_TradingGeneric:1_0_0" schemaLocation="../XML_TradingGeneric/XML_trading_generic.xsd" />
	<xs:include schemaLocation="./XML_productHeader_scheme.xsd" />
	<!-- ************************************************ -->
	<!-- *** Domain : Product : Complex types *** -->
	<xs:complexType name="XML_LinkProductIdentifier">
		<xs:sequence>
			<xs:element name="productLinkType" type="PHD:productLinkTypeScheme">
				<xs:annotation>
					<xs:documentation>
						<definition>Link type with another product (SlaveExercise or MasterExercise)</definition>
					</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="linkedProductId" type="REF:XML_Id">
				<xs:annotation>
					<xs:documentation>
						<definition>Link to a product identifier</definition>
					</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="XML_ObservableIdentifier">
		<xs:annotation>
			<xs:documentation>
				<definition>Container that holds the minimum set of information to identify and process an observable. Currently
					defined as an id or a Reference (Technical pointer).
				</definition>
				<example>Fp an option where a CAC 40 value will trigger some sort of payment, the CAC40 is the observable.</example>
			</xs:documentation>
		</xs:annotation>
		<xs:choice>
			<xs:element ref="PHD:observableId" />
			<xs:element ref="PHD:observableReference" />
		</xs:choice>
	</xs:complexType>
	<xs:complexType name="XML_ProductDates">
		<xs:annotation>
			<xs:documentation>
				<definition>Countainer for the generic dates that can be found on most products. Some of those dates are optional
					since thay may not not be applicable to all products.</definition>
			</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="startDate" type="xs:date" minOccurs="0">
				<xs:annotation>
					<xs:documentation>
						<definition>Start date of the product - correspond to effective beginning of product life</definition>
					</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="effectiveMaturityDate" type="xs:date" minOccurs="0">
				<xs:annotation>
					<xs:documentation>
						<definition>Effective End date of the product or Expiration Date of an option if early termination of the product</definition>
					</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="maturityDate" type="xs:date" minOccurs="0">
				<xs:annotation>
					<xs:documentation>
						<definition>End date of the product or Expiration Date of an option - known at productInput Date</definition>
					</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="maturityDateType" type="PHD:maturityDateTypeScheme">
				<xs:annotation>
					<xs:documentation>
						<definition>The type defining the maturityDate element. This type may be one of several values: fixed, open,
							theoretical</definition>
					</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="XML_ProductHeader">
		<xs:sequence>
			<xs:element name="productIdentifier" type="PHD:XML_ProductIdentifier" minOccurs="0">
				<xs:annotation>
					<xs:documentation>
						<definition>This element uniquely identifies a versioned product. </definition>
					</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="productInfo" type="PHD:XML_ProductInfo" minOccurs="0">
				<xs:annotation>
					<xs:documentation>
						<definition>This element contains the basic information on a product that will help transversal functions in the
							processing of a product.
						</definition>
						<domain>Product Description</domain>
					</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="productStructureReference" type="REF:XML_Reference" minOccurs="0">
				<xs:annotation>
					<xs:documentation>
						<definition>product Structure reference</definition>
					</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="XML_ProductIdentifier">
		<xs:sequence>
			<xs:element name="productId" type="REF:XML_Id">
				<xs:annotation>
					<xs:documentation>
						<definition>Unique identifier of a product.</definition>
						<idScheme>Must be a valid idScheme among the liste of available idSchemes. i.e. share for share listed
							instruments. For market data attached to product, the same idScheme MUST be used when sending the productId as
							part of the static definition and the productId as part of the market data model. Contact ITEC-CRS-DMS-DAS in
							case of doubts</idScheme>
					</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="productVersion" type="PHD:XML_ProductVersion" minOccurs="0">
				<xs:annotation>
					<xs:documentation>
						<definition>The date range over which a version is valid together with a version number. There may be several
							version within a day and therefore the date range of the version uses timestamps.</definition>
					</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="productCode" type="REF:XML_Code" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>
						<definition>Product Codification for other Referentials that manage the same product</definition>
						<codingScheme>TAUProduct,HORUSProduct...</codingScheme>
					</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="productLinkIdentifier" type="PHD:XML_LinkProductIdentifier" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>
						<definition>define product link for product generated after another product (like option Exercise)</definition>
					</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="XML_ProductInfo">
		<xs:annotation>
			<xs:documentation>
				<definition>This element contains the basic information on a product that will help transversal functions in the
					processing of a product.
				</definition>
			</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element ref="PHD:productMnemonic" minOccurs="0" />
			<xs:element ref="PHD:productName" />
			<xs:element ref="PHD:productLongName" minOccurs="0" />
			<xs:element name="productDates" type="PHD:XML_ProductDates" minOccurs="0">
				<xs:annotation>
					<xs:documentation>
						<definition>Countainer for the generic dates that can be found on most products. Some of those dates are optional
							since thay may not not be applicable to all products.</definition>
					</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element ref="PHD:productReferenceQuantity" />
			<xs:element name="productReferenceParty" type="PHD:XML_ProductReferenceParty" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>
						<definition>Identification of a reference party for this product. The identification may be through an Id or
							through a reference (Technical pointer) to a party description that may be else where in the message. For example
							in the detailed product description.</definition>
					</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="XML_ProductReferenceParty">
		<xs:annotation>
			<xs:documentation>
				<definition>Identification of a reference party for this product. The identification may be through an Id or through
					a reference (Technical pointer) to a party description that may be else where in the message. For example in the
					detailed product description.</definition>
			</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:choice>
				<xs:element name="productPartyReference" type="REF:XML_Reference">
					<xs:annotation>
						<xs:documentation>
							<definition>A reference (Pointer) to the definition of the party. This description will be found in the full
								product description. To be Defined</definition>
						</xs:documentation>
					</xs:annotation>
				</xs:element>
				<xs:element name="productPartyId" type="REF:XML_Id">
					<xs:annotation>
						<xs:documentation>
							<definition>A Unique Id of the party. This description will be found in the full product description. To be
								Defined</definition>
							<idScheme>party</idScheme>
						</xs:documentation>
					</xs:annotation>
				</xs:element>
			</xs:choice>
			<xs:element name="productPartyRole" type="PHD:productPartyRoleScheme">
				<xs:annotation>
					<xs:documentation>
						<definition>The role that the party has in the description of the product.</definition>
					</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="XML_ProductSpecificTypology">
		<xs:sequence>
			<xs:element ref="PHD:productSpecificFamilyCode" minOccurs="0" />
			<xs:element ref="PHD:productSpecificTypeCode" minOccurs="0" />
			<xs:element ref="PHD:productSpecificSubTypeCode" minOccurs="0" />
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="XML_ProductStructureTypology">
		<xs:sequence>
			<xs:element ref="PHD:productClass" />
			<xs:element ref="PHD:productStructureType" />
			<xs:element ref="PHD:productStructureSubTypeCode" minOccurs="0" />
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="XML_ProductTypologyInfo">
		<xs:annotation>
			<xs:documentation>
				<definition>This element is the place where we store and send the different typologies in the header. This header
					caries both the current versions of the different typologies and the target version.</definition>
			</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="productStructureTypology" type="PHD:XML_ProductStructureTypology" minOccurs="0">
				<xs:annotation>
					<xs:documentation>
						<definition>current DEFIML structure typology</definition>
					</xs:documentation>
				</xs:annotation>
			</xs:element>
			<!-- <xs:element name="productCommercialTypology" type="PHD:XML_ProductCommercialTypology" minOccurs="0"> <xs:annotation>
				<xs:documentation> <definition>product typology informations</definition> </xs:documentation> </xs:annotation> </xs:element> -->
			<xs:element ref="PHD:productSpecificTypology" minOccurs="0" />
			<xs:element name="referentialInstrumentTypology" type="PHD:XML_ReferentialInstrumentTypology" minOccurs="0">
				<xs:annotation>
					<xs:documentation>
						<definition>Referential Tools are allocating typologies to the instruments stored in them.
							Since we are using this header in the static description of the instruments as well as the OTC products, this
							explains this container.</definition>
					</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="XML_ProductVersion">
		<xs:sequence>
			<xs:element name="versionNumber" type="xs:string" />
			<xs:element name="validityDatetimeRange" type="REF:XML_DatetimeRange" minOccurs="0">
				<xs:annotation>
					<xs:documentation>
						<definition>Timerange range during which the entity is valid.</definition>
					</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="productVersionCreationTimestamp" type="xs:dateTime" minOccurs="0">
				<xs:annotation>
					<xs:documentation>
						<definition>The creation timestamp of a version .</definition>
					</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="XML_ReferentialInstrumentTypology">
		<xs:sequence>
			<xs:element name="instrumentCategory" type="REF:instrumentCategoryScheme" minOccurs="0">
				<xs:annotation>
					<xs:documentation>
						<definition>Instrument Category. High level classification of the financial instrument.</definition>
					</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="instrumentTypeCode" type="REF:XML_Code" minOccurs="0">
				<xs:annotation>
					<xs:documentation>
						<definition>Indicates the type of instrument within the category. This is a finer classification than the
							instrument category.</definition>
					</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<!-- ************************************************ -->
	<!-- *** Domain : Product : Ids *** -->
	<!-- ********************************************** -->
	<!-- *** Domain : Product : Elements *** -->
	<xs:element name="observableId" type="REF:XML_Id">
		<xs:annotation>
			<xs:documentation>
				<definition>Uniq identifier of the instrument/product/ that will have an influence on the valuation of the product.
					The observable type will describe the type of observable. This is a variable that will condition the optional
					conditions of an optoin for example.</definition>
				<idScheme>observable</idScheme>
			</xs:documentation>
		</xs:annotation>
	</xs:element>
	<xs:element name="observableReference" type="REF:XML_Reference">
		<xs:annotation>
			<xs:documentation>
				<definition>reference (Pointer) to the description of an observable. This points at a description that is held in
					the detailed description of the product.</definition>
			</xs:documentation>
		</xs:annotation>
	</xs:element>
	<!-- <xs:element name="productCategoryCode" type="REF:XML_Code"> <xs:annotation> <xs:documentation> <definition>Business
		category - productClass specific</definition> <codingScheme>defiCommercialTypology</codingScheme> </xs:documentation> </xs:annotation>
		</xs:element> -->
	<xs:element name="productClass" type="PHD:productClassScheme">
		<xs:annotation>
			<xs:documentation>
				<definition>High-level product Class</definition>
				<samples>bond,ird,creder,fx...</samples>
			</xs:documentation>
		</xs:annotation>
	</xs:element>
	<xs:element name="productLongName" type="xs:string">
		<xs:annotation>
			<xs:documentation>
				<definition>A long description of the product.</definition>
			</xs:documentation>
		</xs:annotation>
	</xs:element>
	<xs:element name="productMnemonic" type="xs:string">
		<xs:annotation>
			<xs:documentation>
				<definition>The mnemonic of the product is expected to be used for fast data input. When existant is must be unique
					for the product.</definition>
			</xs:documentation>
		</xs:annotation>
	</xs:element>
	<xs:element name="productName" type="xs:string">
		<xs:annotation>
			<xs:documentation>
				<definition>Each product should have a name. In some cases this name will be constructed automatically from some
					characteristics of the product. In other cases this name is keyed in specifically for this product.</definition>
			</xs:documentation>
		</xs:annotation>
	</xs:element>
	<xs:element name="productReferenceQuantity" type="xs:decimal">
		<xs:annotation>
			<xs:documentation>
				<definition>Nominal quantity of reference for this product. This quantity is used as a ratio with the quantity
					specified in the associated trade to derive the total quantity involved in the trade. This is filled by convention
					for each type of product. For the example the nominal value of the product.</definition>
				<example>For a Bond this is the nominal of the Bond.</example>
			</xs:documentation>
		</xs:annotation>
	</xs:element>
	<xs:element name="productSpecificFamilyCode" type="REF:XML_Code">
		<xs:annotation>
			<xs:documentation>
				<definition>Specific product family depending of productClass (fx, ird, bond...). This definition belongs to a
					specific business line.</definition>
			</xs:documentation>
		</xs:annotation>
	</xs:element>
	<xs:element name="productSpecificSubTypeCode" type="REF:XML_Code">
		<xs:annotation>
			<xs:documentation>
				<definition>Specific product subtype depending of productClass (fx, ird, bond...). The content of this item is
					specific to a business line.</definition>
			</xs:documentation>
		</xs:annotation>
	</xs:element>
	<xs:element name="productSpecificTypeCode" type="REF:XML_Code">
		<xs:annotation>
			<xs:documentation>
				<definition>specific product type depending of productClass (fx, ird, bond...). The content of this item is specific
					to a business line.</definition>
			</xs:documentation>
		</xs:annotation>
	</xs:element>
	<xs:element name="productSpecificTypology" type="PHD:XML_ProductSpecificTypology">
		<xs:annotation>
			<xs:documentation>
				<definition>TRANSITORY : Each business line may have its own internal typology. This typology is for internal
					exchanges only. It may be equivalent to the target typology or not. It is expected that 3 levels of internal
					business line typology fits all business line needs.</definition>
			</xs:documentation>
		</xs:annotation>
	</xs:element>
	<xs:element name="productStructureType" type="xs:string">
		<xs:annotation>
			<xs:documentation>
				<definition>Type of product structure element as defined in FPML nomenclature:
					swap, fxSwap, fxSingleLeg... - to be
					specialized for each productClass - can be "productStructureSet"</definition>
			</xs:documentation>
		</xs:annotation>
	</xs:element>
	<xs:element name="productStructureSubTypeCode" type="REF:XML_Code" />
	<!-- ************************************************ -->
	<!-- *** Domain : Product : Root element *** -->
	<!-- ********************************************** -->
	<xs:element name="productHeader" type="PHD:XML_ProductHeader">
		<xs:annotation>
			<xs:documentation>
				<definition>Product generic parameters</definition>
			</xs:documentation>
		</xs:annotation>
	</xs:element>
</xs:schema>
