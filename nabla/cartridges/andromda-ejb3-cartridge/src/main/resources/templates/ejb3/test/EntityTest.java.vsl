#if ($umlUtils.shouldOutput($entity) && !$entity.abstract)
#parse("templates/ejb3/Globals.vm")
// license-header java merge-point
//
// Attention: Generated code! Do not modify by hand!
//
/**
 * Generated by EntityTest.java.vsl in andromda-ejb3-cartridge on $umlUtils.date.
 */
#if ($stringUtils.isNotBlank($entity.packageName))
package $entity.packageName;
#end
/**
 * TestNG Unit Test to Create and Validate and Update and Delete the $entity.fullyQualifiedName Entity
 */
#set ($generatedFile = "${stringUtils.replace($entity.fullyQualifiedName,'.','/')}EntityTest.java")

import com.wdpr.dbtest.JPAJUnitAncestor;
import org.apache.log4j.LogManager;
import org.apache.log4j.Logger;
import org.testng.annotations.AfterClass;
import org.testng.annotations.AfterMethod;
import org.testng.annotations.Test;
import org.testng.annotations.BeforeMethod;
import org.testng.annotations.BeforeClass;
import org.testng.Assert;

/**
 * Create ${entity.tableName} row from ${entity.entityName} Entity
 */
public class ${entity.entityName}EntityTest extends JPAJUnitAncestor
{
#set ($entityVariable = $stringUtils.uncapitalize($entity.entityName))
    /** Persisted Entity to retrieve and update and delete from */
    protected static $entity.fullyQualifiedName entity = null;

    /**
     * Creates ${entity.tableName} record
     */
    @Test(groups = { "creates" })
    public void testCreate${entity.entityName}()
    {
        // Delete all rows from table  - avoid duplicate PK error
        //this.deleteAll();
        this.em.getTransaction().begin();
        LOGGER.info("testCreate${entity.entityName}");
        $entity.fullyQualifiedName $entityVariable = ${entity.entityName}Create.createEntity();
        LOGGER.info("persisting ${entity.entityName}: " + $entityVariable);
        this.em.persist($entityVariable);
        this.em.getTransaction().commit();
        int results = this.logEntities();
        // Will also fail if all rows are not deleted during setUp
        Assert.assertTrue(results > 0, "${entity.entityName} inserted but record not found");
        // Save PK for later retrieve/delete
        ${entity.entityName}EntityTest.entity = $entityVariable;
    }

    /**
     * Retrieving $entity.tableName record
     */
    @Test(groups = { "retrieves" })
    public void testRetrieve${entity.entityName}()
    {
        LOGGER.info("testDelete${entity.entityName}");
#if ($entity.compositePrimaryKeyPresent)
        $entity.fullyQualifiedEntityCompositePrimaryKeyName pk = ${entity.entityName}Create.createEntityPK(true);
#else
#set ($identifier = $entity.identifier)
#set ($constructor=$umlUtils.createConstructor($identifier, false, $entity))
        $identifier.type.fullyQualifiedName pk = $constructor;
#end
        $entity.entityName $entityVariable = this.em.find(${entity.entityName}.class, pk);
        if (${entityVariable}==null)
        {
            Assert.fail("$entity.entityName not found for Primary Key value: " + pk);
        }
        else
        {
            LOGGER.info("deleting $entity.entityName:" + $entityVariable);
        }
    }

    /**
     * Deleting $entity.tableName record
     */
    @Test(groups = { "deletes" })
    public void testDelete${entity.entityName}()
    {
        LOGGER.info("testDelete${entity.entityName}");
        // Reattach persisted object before removal
        if (${entity.entityName}EntityTest.entity==null)
        {
            Assert.fail("$entity.entityName was null");
        }
        ${entity.entityName}EntityTest.entity = this.em.merge(${entity.entityName}EntityTest.entity);
        if (${entity.entityName}EntityTest.entity==null)
        {
            Assert.fail("$entity.entityName not found");
        }
        LOGGER.info("deleting $entity.entityName: " + ${entity.entityName}EntityTest.entity);
        this.em.remove(${entity.entityName}EntityTest.entity);
    }

    private static Logger LOGGER = LogManager.getLogger(${entity.entityName}EntityTest.class);
    /**
     * Add any custom code to be executed once before any tests are executed
     */
    @BeforeClass(alwaysRun=true)
    public void setUpBeforeClass()
    {
        super.setUpBeforeClass();
        // Insert code here to be executed before any tests are run
    }

    /**
     * Add any custom code to be executed once after all tests are executed
     */
    @AfterClass(alwaysRun=true)
    public void tearDownAfterClass()
    {
        super.tearDownAfterClass();
        // Insert code here to be executed after tests are complete
        super.closeAll();
    }

    /**
     * Add any custom code to be executed before each tests are executed
     */
    @Override
    @BeforeMethod(alwaysRun=true)
    public void setUp()
    {
        super.setUp();
    }

    /**
     * Add any custom code to be executed after each tests are executed
     */
    @Override
    @AfterMethod(alwaysRun=true)
    public void tearDown()
    {
        super.tearDown();
    }

    /**
     * Unit test Constructor with no arguments
     */
    public ${entity.entityName}EntityTest()
    {
        super();
        // Public no arg constructor
        this.entityName = "$entity.entityName";
        this.table = "$entity.tableName";
    }

    /**
     * Unit test Constructor with test case name
     * @param name test case name
     */
    public ${entity.entityName}EntityTest(final String name)
    {
        super(name);
        this.entityName = "$entity.entityName";
        this.table = "$entity.tableName";
    }
}
#end
