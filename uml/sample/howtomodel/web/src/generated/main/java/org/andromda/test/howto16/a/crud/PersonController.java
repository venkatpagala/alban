// license-header java merge-point
// Generated by andromda-jsf cartridge (controllers\crud\Controller.java.vsl) DO NOT EDIT!
package org.andromda.test.howto16.a.crud;

import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.Map;
import javax.faces.component.UIParameter;
import javax.faces.context.FacesContext;
import javax.faces.el.ValueBinding;
import javax.faces.event.ActionEvent;
import javax.faces.model.SelectItem;
import org.andromda.presentation.jsf.ControllerBase;
import org.andromda.presentation.jsf.Messages;
import org.andromda.presentation.jsf.PatternMatchingExceptionHandler;
import org.andromda.test.ManageableServiceLocator;
import org.apache.commons.lang.ObjectUtils;
import org.apache.commons.lang.StringUtils;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

/**
 * Java Server Faces Controller of the Person CRUD management.
 */
public abstract class PersonController
    extends ControllerBase
{
    private static final Log logger = LogFactory.getLog(PersonController.class);

    /**
     * Initializes the controller, calling the doInit method
     *
     * @return the controller view path.
     */
    public String init()
    {
        this.resetUseCaseFormsAndPageVariables();

        try
        {
            final ManagePersonForm form = this.getForm();

            try
            {
                this.setCurrentActionForm(form);
                this.doInit(form);
            }
            catch (final Throwable throwable)
            {
                final String messageKey = PatternMatchingExceptionHandler.instance().handleException(throwable);
                // - the exception is re-thrown by the exception handler and handled by the catch below if it can't get a messageKey
                //   (no reason to check for presence of messageKey)
                this.addErrorMessage(Messages.get(messageKey, null));
            }
        }
        catch (final Throwable throwable)
        {
            logger.error(throwable.getMessage(),throwable);
            this.addExceptionMessage(throwable);
        }
        return "/org/andromda/test/howto16/a/crud/person-crud";
    }

    /**
     * Initializes the controller. This method can be overridden.
     * @param form
     * @throws Exception
     */
    public void doInit(ManagePersonForm form)
        throws Exception
    {

        form.getSearchForm().setName(null);
        form.getSearchForm().setBirthDate(null);
        form.getSearchForm().setCars(null);

        form.setManageableList(null);

        final Map<String,?> backingLists = ManageableServiceLocator.instance().getPersonManageableService().readBackingLists();
        form.setCarsBackingList((Collection)backingLists.get("cars"));

        form.setEditState(false);
    }

    /**
     * The instance load action.
     * @param event
     */
    public void load(ActionEvent event)
    {
        try
        {
            final ManagePersonForm form = this.getForm();

            try
            {
                this.setCurrentActionForm(form);
                this.doLoad(String.valueOf(((UIParameter)event.getComponent().findComponent("serial")).getValue().toString()),form);
            }
            catch (final Throwable throwable)
            {
                final String messageKey = PatternMatchingExceptionHandler.instance().handleException(throwable);
                // - the exception is re-thrown by the exception handler and handled by the catch below if it can't get a messageKey
                //   (no reason to check for presence of messageKey)
                this.addErrorMessage(Messages.get(messageKey, null));
            }
            resetAllEditableComponentsValues();
        }
        catch (final Throwable throwable)
        {
            logger.error(throwable.getMessage(),throwable);
            this.addExceptionMessage(throwable);
        }
    }

    /**
     * Loads the selected instance.
     * @param id
     * @param form
     * @throws Exception
     */
    public void doLoad(String serial, ManagePersonForm form)
        throws Exception
    {
        final PersonValueObject vo=
            ManageableServiceLocator.instance().getPersonManageableService().readById(serial);

        form.setName(vo.getName());
        form.setBirthDate(vo.getBirthDate());
        form.setSerial(vo.getSerial());
        form.setCars(vo.getCars());

        form.setEditState(true);
    }

    /**
     * The cancel edit action
     *
     * @return the controller view path.
     */
    public String cancel()
    {
        try
        {
            final ManagePersonForm form = this.getForm();

            try
            {
                this.setCurrentActionForm(form);
                this.doCancel(form);
            }
            catch (final Throwable throwable)
            {
                final String messageKey = PatternMatchingExceptionHandler.instance().handleException(throwable);
                // - the exception is re-thrown by the exception handler and handled by the catch below if it can't get a messageKey
                //   (no reason to check for presence of messageKey)
                this.addErrorMessage(Messages.get(messageKey, null));
            }
        }
        catch (final Throwable throwable)
        {
            logger.error(throwable.getMessage(),throwable);
            this.addExceptionMessage(throwable);
        }

        resetAllEditableComponentsValues();
        return null;
    }

    /**
     * Executes the edit cancel.
     * @param form
     * @throws Exception
     */
    public void doCancel(ManagePersonForm form)
        throws Exception
    {
        form.setEditState(false);
    }

    /**
     * The new instance action.
     *
     * @return the controller view path.
     */
    public String startNew()
    {
        try
        {
            final ManagePersonForm form = this.getForm();

            try
            {
                this.setCurrentActionForm(form);
                this.doStartNew(form);
            }
            catch (final Throwable throwable)
            {
                final String messageKey = PatternMatchingExceptionHandler.instance().handleException(throwable);
                // - the exception is re-thrown by the exception handler and handled by the catch below if it can't get a messageKey
                //   (no reason to check for presence of messageKey)
                this.addErrorMessage(Messages.get(messageKey, null));
            }
        }
        catch (final Throwable throwable)
        {
            logger.error(throwable.getMessage(),throwable);
            this.addExceptionMessage(throwable);
        }

        resetAllEditableComponentsValues();
        return null;
    }

    /**
     * Executes the new instance action.
     * @param form
     * @throws Exception
     */
    public void doStartNew(ManagePersonForm form)
        throws Exception
    {
        form.setName(null);
        form.setBirthDate(null);
        form.setSerial(null);

        form.setCars(null);

        final Map backingLists = ManageableServiceLocator.instance().getPersonManageableService().readBackingLists();
        form.setCarsBackingList((Collection)backingLists.get("cars"));

        form.setEditState(true);
    }

    /**
     * The save instance action.
     *
     * @return the controller view path.
     */
    public String save()
    {
        try
        {
            final ManagePersonForm form = this.getForm();

            try
            {
                this.setCurrentActionForm(form);
                this.doSave(form);
            }
            catch (final Throwable throwable)
            {
                final String messageKey = PatternMatchingExceptionHandler.instance().handleException(throwable);
                // - the exception is re-thrown by the exception handler and handled by the catch below if it can't get a messageKey
                //   (no reason to check for presence of messageKey)
                this.addErrorMessage(Messages.get(messageKey, null));
            }
        }
        catch (final Throwable throwable)
        {
            logger.error(throwable.getMessage(),throwable);
            this.addExceptionMessage(throwable);
        }

        resetAllEditableComponentsValues();
        return null;
    }

    /**
     * Saves instance action.
     * @param form
     * @throws Exception
     */
    public void doSave(ManagePersonForm form)
        throws Exception
    {
        if(form.getSerial() == null){
            form.setSerial(
                ManageableServiceLocator.instance().getPersonManageableService().create(
                    form.getName()
                    , form.getBirthDate()
                    , null
                    , form.getCars()
                ).getSerial()
            );
            this.addInfoMessage(Messages.get("manageable.entity.created", new Object[]{Messages.get("person")}));
        }
        else{
            ManageableServiceLocator.instance().getPersonManageableService().update(
                form.getName()
                , form.getBirthDate()
                , form.getSerial()
                , form.getCars()
            );
            this.addInfoMessage(Messages.get("manageable.entity.changed", new Object[]{Messages.get("person")}));
        }
        if(form.getManageableList() != null) //only searches again if there was an old search
            doSearch(form); //search again to show the updated item (if it fits the search criteria)

        form.setEditState(false);
    }

    /**
     * The save and new instance action.
     *
     * @return the controller view path.
     */
    public String saveAndNew()
    {
        try
        {
            final ManagePersonForm form = this.getForm();

            try
            {
                this.setCurrentActionForm(form);
                this.doSave(form);
                this.doStartNew(form);
            }
            catch (final Throwable throwable)
            {
                final String messageKey = PatternMatchingExceptionHandler.instance().handleException(throwable);
                // - the exception is re-thrown by the exception handler and handled by the catch below if it can't get a messageKey
                //   (no reason to check for presence of messageKey)
                this.addErrorMessage(Messages.get(messageKey, null));
            }
        }
        catch (final Throwable throwable)
        {
            logger.error(throwable.getMessage(),throwable);
            this.addExceptionMessage(throwable);
        }

        resetAllEditableComponentsValues();
        return null;
    }

    /**
     * The search action.
     *
     * @return the controller view path.
     */
    public String search()
    {
        try
        {
            final ManagePersonForm form = this.getForm();

            try
            {
                this.setCurrentActionForm(form);
                this.doSearch(form);
            }
            catch (final Throwable throwable)
            {
                final String messageKey = PatternMatchingExceptionHandler.instance().handleException(throwable);
                // - the exception is re-thrown by the exception handler and handled by the catch below if it can't get a messageKey
                //   (no reason to check for presence of messageKey)
                this.addErrorMessage(Messages.get(messageKey, null));
            }
        }
        catch (final Throwable throwable)
        {
            logger.error(throwable.getMessage(),throwable);
            this.addExceptionMessage(throwable);
        }

        resetAllEditableComponentsValues();
        return null;
    }

    /**
     * Executes the search action.
     * @param form
     * @throws Exception
     */
    public void doSearch(ManagePersonForm form)
        throws Exception
    {
        @SuppressWarnings("rawtypes")
        final List list;
        //if all search fields are null, call readAll()
        if (
             StringUtils.isBlank(form.getSearchForm().getName())
            && form.getSearchForm().getBirthDate() == null
            && form.getSearchForm().getCars() == null
            )
            list=ManageableServiceLocator.instance().getPersonManageableService().readAll();
        else
            list = ManageableServiceLocator.instance().getPersonManageableService().read(
                form.getSearchForm().getName()
                , form.getSearchForm().getBirthDate()
                , null
                , form.getSearchForm().getCars()
            );

        form.setManageableList(list);
        if (list.size() >= 250)
            saveMaxResultsWarning();

        final Map<String,?> backingLists = ManageableServiceLocator.instance().getPersonManageableService().readBackingLists();
        form.setCarsBackingList((Collection)backingLists.get("cars"));

        form.setEditState(false);
    }

    /**
     * The delete event.
     * @param event
     */
    public void delete(ActionEvent event)
    {
        try
        {
            final ManagePersonForm form = this.getForm();

            try
            {
                this.setCurrentActionForm(form);
                this.doDelete(String.valueOf(((UIParameter)event.getComponent().findComponent("serial")).getValue().toString()),form);
            }
            catch (final Throwable throwable)
            {
                final String messageKey = PatternMatchingExceptionHandler.instance().handleException(throwable);
                // - the exception is re-thrown by the exception handler and handled by the catch below if it can't get a messageKey
                //   (no reason to check for presence of messageKey)
                this.addErrorMessage(Messages.get(messageKey, null));
            }
            resetAllEditableComponentsValues();
        }
        catch (final Throwable throwable)
        {
            logger.error(throwable.getMessage(),throwable);
            this.addExceptionMessage(throwable);
        }
    }

    /**
     * Deletes the selected instance.
     * @param id
     * @param form
     * @throws Exception
     */
    public void doDelete(String serial, ManagePersonForm form)
        throws Exception
    {
        ManageableServiceLocator.instance().getPersonManageableService().delete(new String[]{serial});
        this.addInfoMessage(Messages.get("manageable.entity.deleted", new Object[]{Messages.get("person")}));

        doSearch(form);
    }

    /**
     * Shows a message warning the user can exists more records available.
     */
    private void saveMaxResultsWarning()
    {
        addWarningMessage(Messages.get("maximum.results.fetched.warning", new Object[]{String.valueOf("250")}));
    }

    /**
     * Export as ODS spreadsheet
     * @return /org/andromda/test/howto16/a/crud/person-ods-export
     */
    public String odsExport()
    {
        return "/org/andromda/test/howto16/a/crud/person-ods-export";
    }

    /**
     * Helper method to fill the autocomplete component list.
     * @param event
     */
    public void fillAutocomplete(ActionEvent event)
    {
        final FacesContext facesContext = this.getContext();
        final Map<String,String> parameters = facesContext.getExternalContext().getRequestParameterMap();
        final Object fieldValue = parameters.get(this.getParameterValue("searchFieldRequestParamName",event));
        try{
            @SuppressWarnings("rawtypes")
            final List list = ManageableServiceLocator.instance().getPersonManageableService().read(
                (fieldValue==null || fieldValue.toString().length() == 0) ? null : fieldValue.toString()
                , null
                , null
                , null
            );
            final ValueBinding vb = facesContext.getApplication().createValueBinding("#{autocompleteResult}");
            vb.setValue(facesContext, list);
        }
        catch (final Throwable throwable)
        {
            logger.error(throwable.getMessage(),throwable);
            this.addExceptionMessage(throwable);
        }
    }

    /**
     * Loads an instance of Person.
     *
     * @return PersonValueObject from the loaded entity.
     */
    static public PersonValueObject load(String serial)
    {
        if(serial == null || StringUtils.isBlank(serial))
        {
            return null;
        }
        try
        {
            return ManageableServiceLocator.instance().getPersonManageableService().readById(serial);
        }
        catch(Exception e)
        {
            throw new RuntimeException(e);
        }
    }

    /**
     * Helper method to fill the select component list.
     *
     * @return a collection with the filtered list.
     */
    public Collection<SelectItem> getAsSelectItems()
    {
        final Collection<PersonValueObject> vos;
        try {
            vos = ManageableServiceLocator.instance().getPersonManageableService().readAll();
        } catch (final Throwable throwable) {
            logger.error(throwable.getMessage(),throwable);
            this.addExceptionMessage(throwable);
            return null;
        }
        final Collection<SelectItem> result=new ArrayList<SelectItem>(vos.size());
        for(PersonValueObject vo: vos){
            result.add(new SelectItem(vo.getSerial(),ObjectUtils.toString(vo.getName())));
        }
        return result;
    }

    /** manageTaskForm */
    public static final String FORM_BEAN_NAME="managePersonForm";

    /**
     * Resolves "managePersonForm".
     *
     * @return the manageable form.
     */
    public ManagePersonForm getForm()
    {
        final Map<String,Object> forms=getForms();
        ManagePersonForm form=(ManagePersonForm)forms.get(FORM_BEAN_NAME);
        if(form == null){
            form = new ManagePersonForm();
            forms.put(FORM_BEAN_NAME,form);
        }
        return form;
    }

    // crud-controller merge-point
}